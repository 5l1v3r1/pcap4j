/*_##########################################################################
  _##
  _##  Copyright (C) 2016 Pcap4J.org
  _##
  _##########################################################################
*/

buildscript {
  repositories {
    jcenter()
    maven {
      url "https://plugins.gradle.org/m2/"
    }
  }
  dependencies {
    classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
    classpath "com.diffplug.spotless:spotless-plugin-gradle:3.16.0"
  }
}

allprojects {
  apply plugin: 'java-library'
  apply plugin: "com.diffplug.gradle.spotless"

  group = 'org.pcap4j'
  version = '2.0.0-alpha.6-SNAPSHOT'

  javadoc {
    def currentYear = Calendar.getInstance().get Calendar.YEAR
    options.with {
      locale 'en_US'
      encoding 'UTF-8'
      charSet 'UTF-8'
      author true
      windowTitle "Pcap4J ${project.version}"
      header "Pcap4J ${project.version}"
      docTitle "Pcap4J ${project.version} API Documentation"
      footer 'https://github.com/kaitoy/pcap4j'
      bottom "Copyright &copy; 2011 - ${currentYear} Pcap4J.org. All rights reserved."
      showFromProtected()
      addStringOption 'Xdoclint:all,-reference', '-quiet'
    }
    excludes = ['**/module-info.java']
  }

  spotless {
    lineEndings 'UNIX'
    java {
      googleJavaFormat()
      removeUnusedImports()
      trimTrailingWhitespace()
      endWithNewline()
    }
  }

  [compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

  repositories {
    jcenter()
  }

  gradle.projectsEvaluated {
    tasks.withType(JavaCompile) {
      options.compilerArgs << "-Xlint:unchecked,deprecation"
    }
  }
}

subprojects {
  compileJava {
    doFirst {
      options.compilerArgs = [
        '--module-path', classpath.asPath,
        '--release', "9",
      ]
      classpath = files()
    }
  }

  task compileJava8 (type: JavaCompile) {
    sourceCompatibility = 8
    targetCompatibility = 8
    source = compileJava.source
    destinationDir = compileJava.destinationDir
    classpath = compileJava.classpath
    excludes = ['**/module-info.java']
  }
  compileJava.finalizedBy compileJava8

  compileTestJava {
    sourceCompatibility = 8
    targetCompatibility = 8
  }

  test {
    useJUnitPlatform()

    ext.junitModuleName = 'org.junit.jupiter.api'
    ext.junitPlatformCommonsName = 'org.junit.platform.commons'
    doLast {
      jvmArgs = [
        '--module-path', classpath.asPath,
        '--add-modules', 'ALL-MODULE-PATH',
        '--add-reads', "$moduleName=$junitModuleName",
        '--add-reads', "$moduleName=slf4j.api",
        '--patch-module', "$moduleName=" + files(sourceSets.test.java.outputDir).asPath,
        '--add-opens', "$moduleName/org.pcap4j.test.core=$junitPlatformCommonsName",
        '--add-opens', "$moduleName/org.pcap4j.test.packet=$junitPlatformCommonsName",
        '--add-opens', "$moduleName/org.pcap4j=$junitPlatformCommonsName",
      ]
      classpath = files()
    }
  }

  task testJre8 (type: Test) {
    useJUnitPlatform()
    if (project.hasProperty('jre8_bin_path')) {
      executable = project.findProperty('jre8_bin_path')
    } else {
      enabled = false
    }
  }
  test.finalizedBy testJre8
}

if (!gradle.startParameter.taskNames.find({ it.endsWith('javadoc') })) {
  subprojects {
    if (project.hasProperty('javadoc')) {
      project.javadoc.enabled = false
    }
  }
}

archivesBaseName = 'pcap4j'
description = 'A Java library for capturing, crafting and sending packets.'

configurations {
  javadocJar
}

dependencies {
  // for javadoc task
  implementation "org.slf4j:slf4j-api:${slf4jVer}"
  implementation "net.java.dev.jna:jna:${jnaVer}"
}

jar.enabled = false

task jarJavadoc(type: Jar, dependsOn: javadoc) {
  classifier = 'javadoc'
  from javadoc.destinationDir
}

// aggregated javadoc
javadoc {
  def srcDirs = []
  subprojects.each { proj ->
    srcDirs.addAll proj.sourceSets.main.java.srcDirs
  }
  source srcDirs
  excludes = ['**/module-info.java']
}

artifacts {
  // jarJavadoc.archivePath instead of jarJavadoc so that build task doesn't depend on javadoc task.
  javadocJar jarJavadoc.archivePath
}

// remove the output of jar task from archives
configurations.archives.artifacts.with { artifacts ->
  artifacts.remove artifacts.find { !it.classifier }
}

// dist task
apply from: 'gradle/distribution.gradle'

// genScript task
if (gradle.startParameter.taskNames.contains('genScript')) {
  apply from: 'gradle/genScript.gradle'
}

// genScriptForDocker task
if (gradle.startParameter.taskNames.contains('genScriptForDocker')) {
  apply from: 'gradle/genScriptForDocker.gradle'
}

// upload
if (
     gradle.startParameter.taskNames.contains('bintrayUpload')
  || gradle.startParameter.taskNames.contains('uploadArchives')
) {
  apply from: 'gradle/upload.gradle'
}

// code coverage
if (gradle.startParameter.taskNames.contains('jacocoTestReport')) {
  apply from: 'gradle/jacoco.gradle'
}
