/*_##########################################################################
  _##
  _##  Copyright (C) 2016 Pcap4J.org
  _##
  _##########################################################################
*/

buildscript {
  repositories {
    jcenter()
    maven {
      url "https://plugins.gradle.org/m2/"
    }
  }
  dependencies {
    classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
    classpath "com.diffplug.spotless:spotless-plugin-gradle:3.16.0"
  }
}

allprojects {
  apply plugin: 'java-library'
  apply plugin: "com.diffplug.gradle.spotless"

  group = 'org.pcap4j'
  version = '2.0.0-alpha.4-SNAPSHOT'

  javadoc {
    def currentYear = Calendar.getInstance().get Calendar.YEAR
    options.with {
      locale 'en_US'
      encoding 'UTF-8'
      charSet 'UTF-8'
      author true
      windowTitle "Pcap4J ${project.version}"
      header "Pcap4J ${project.version}"
      docTitle "Pcap4J ${project.version} API Documentation"
      footer 'https://github.com/kaitoy/pcap4j'
      bottom "Copyright &copy; 2011 - ${currentYear} Pcap4J.org. All rights reserved."
      showFromProtected()
      addStringOption 'Xdoclint:all,-reference', '-quiet'
    }
  }

  spotless {
    lineEndings 'UNIX'
    java {
      googleJavaFormat()
      removeUnusedImports()
      trimTrailingWhitespace()
      endWithNewline()
    }
  }

  [compileJava, compileTestJava]*.options*.encoding = 'UTF-8'
  sourceCompatibility = 1.8
  targetCompatibility = 1.8

  repositories {
    jcenter()
  }

  gradle.projectsEvaluated {
    tasks.withType(JavaCompile) {
      options.compilerArgs << "-Xlint:unchecked,deprecation"
    }
  }
}

subprojects {
  test {
    useJUnitPlatform()
  }

  afterEvaluate {
    jar {
      inputs.property("moduleName", moduleName)
      manifest {
        attributes('Automatic-Module-Name': moduleName)
      }
    }
  }
}

if (!gradle.startParameter.taskNames.find({ it.endsWith('javadoc') })) {
  subprojects {
    if (project.hasProperty('javadoc')) {
      project.javadoc.enabled = false
    }
  }
}

archivesBaseName = 'pcap4j'
description = 'A Java library for capturing, crafting and sending packets.'

configurations {
  javadocJar
}

dependencies {
  // for javadoc task
  implementation "org.slf4j:slf4j-api:${slf4jVer}"
  implementation "net.java.dev.jna:jna:${jnaVer}"
}

jar.enabled = false

task jarJavadoc(type: Jar, dependsOn: javadoc) {
  classifier = 'javadoc'
  from javadoc.destinationDir
}

// aggregated javadoc
javadoc {
  def srcDirs = []
  subprojects.each { proj ->
    srcDirs.addAll proj.sourceSets.main.java.srcDirs
  }
  source srcDirs
}

artifacts {
  // jarJavadoc.archivePath instead of jarJavadoc so that build task doesn't depend on javadoc task.
  javadocJar jarJavadoc.archivePath
}

// remove the output of jar task from archives
configurations.archives.artifacts.with { artifacts ->
  artifacts.remove artifacts.find { !it.classifier }
}

// dist task
apply from: 'gradle/distribution.gradle'

// genScript task
if (gradle.startParameter.taskNames.contains('genScript')) {
  apply from: 'gradle/genScript.gradle'
}

// genScriptForDocker task
if (gradle.startParameter.taskNames.contains('genScriptForDocker')) {
  apply from: 'gradle/genScriptForDocker.gradle'
}

// upload
if (
     gradle.startParameter.taskNames.contains('bintrayUpload')
  || gradle.startParameter.taskNames.contains('uploadArchives')
) {
  apply from: 'gradle/upload.gradle'
}

// code coverage
if (gradle.startParameter.taskNames.contains('jacocoTestReport')) {
  apply from: 'gradle/jacoco.gradle'
}
